-- Data backend for KAIR platform


CREATE USER kair with password 'kair_pass';

create role kair with login password 'kair_pass';

grant connect on database postgres to kair;
grant usage on schema public to kair;

-- Vector DB index extension
CREATE EXTENSION IF NOT EXISTS vectorscale CASCADE;


------- Crawling tables -------


-- URL items to crawl
CREATE TABLE crawl_queue(
    id integer GENERATED ALWAYS AS IDENTITY NOT NULL,
    create_time date,
    url varchar(4096),
    comment varchar(255),
    PRIMARY KEY(id)
);

-- Items we've already crawled (shared ID with crawl_queue)
CREATE TABLE crawled(
    id integer NOT NULL,
    crawl_time date NOT NULL,
    path varchar(255),
    PRIMARY KEY(id,crawl_time),
    CONSTRAINT crawled_id_fkey FOREIGN key(id) REFERENCES crawl_queue(id)
);


-- A "strategy" is a prompt or command to execute a (named) task.  It might
-- have sub-strategies.  There is also a score for "promise" (how likely it is to
-- be successful) and a scope (what it is expected to work on).  The strategy
-- can also include a JSON object with additional data.
CREATE TABLE strategies(
    strategy_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    strategy_name TEXT,
    strategy_prompt TEXT,
    strategy_promise FLOAT,
    strategy_scope TEXT,
    sub_strategies INTEGER[],
    strategy_json JSON,
    strategy_embed vector(1536),
    description TEXT
);


CREATE INDEX strategy_name_idx ON strategies USING btree ("strategy_name");
CREATE INDEX strategy_embed_idx ON strategies
USING diskann (strategy_embed vector_cosine_ops);
CREATE INDEX strategy_sub_strategies_idx ON strategies USING btree ("sub_strategies");

-- Entities can be any of several classes
CREATE TYPE entity_types AS ENUM ('synopsis', 
                                  'fact', 
                                  'new_concept',
                                  'claim',
                                  'author', 
                                  'organization', 
                                  'tag', 
                                  'paper', 
                                  'section', 
                                  'paragraph',
                                  'table',
                                  'hypothesis',
                                  'source',
                                  'method',
                                  'event',
                                  'result');

ALTER TYPE entity_types ADD VALUE IF NOT EXISTS 'google_scholar_profile';

ALTER TYPE entity_types ADD VALUE IF NOT EXISTS 'learning_resource';
ALTER TYPE entity_types ADD VALUE IF NOT EXISTS 'url';

ALTER TYPE entity_types ADD VALUE IF NOT EXISTS 'accession_number';

ALTER TYPE entity_types ADD VALUE IF NOT EXISTS 'json_data';

-- Data is "chunked" into hierarchies of entities.
-- An entity can be a synopsis, fact, new concept, claim, author, organization,
-- tag, paper, section, paragraph, table, hypothesis, source, method, event,
-- result, etc.  Each entity has a name, a parent (which is another entity),
-- and an embedding.  The embedding is a vector of floats that represents the
-- entity in a high-dimensional space.  The embedding is used for similarity
-- search and other operations.  The entity can also have a detail (a
-- description), a URL (a link to the entity), and a contact (a person or
-- organization to contact for more information).  The entity can also have
-- a JSON object with additional data.  The entity can also have a
-- supporting evidence (another entity that supports the claim).
CREATE TABLE entities(
    entity_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_type entity_types,
    entity_name TEXT,
    entity_parent INTEGER,
    entity_embed vector(1536),
    FOREIGN KEY (entity_parent) REFERENCES entities(entity_id) ON DELETE CASCADE
);

ALTER TABLE entities
    ADD COLUMN IF NOT EXISTS gem_embed halfvec(3072),
    ADD COLUMN IF NOT EXISTS qwen_embed halfvec(3072);

ALTER TABLE entities
    ADD CONSTRAINT unique_entities UNIQUE(entity_type, entity_name),
    ADD CONSTRAINT unique_entity_parent UNIQUE(entity_type, entity_name, entity_parent);
ALTER TABLE entities
    ADD COLUMN IF NOT EXISTS entity_detail TEXT,
    ADD COLUMN IF NOT EXISTS entity_url TEXT,
    ADD COLUMN IF NOT EXISTS entity_contact TEXT,
    ADD COLUMN IF NOT EXISTS entity_json JSON;
ALTER TABLE entities
    ADD COLUMN IF NOT EXISTS supporting_evidence INTEGER,
    ADD FOREIGN KEY (supporting_evidence) REFERENCES entities(entity_id) ON DELETE CASCADE;
ALTER TABLE entities
    ADD FOREIGN KEY (supporting_evidence) REFERENCES entities(entity_id) ON DELETE CASCADE;

ALTER TABLE entities
    DROP CONSTRAINT unique_entities;
ALTER TABLE entities
    ADD CONSTRAINT unique_entities UNIQUE(entity_type, entity_name, entity_url);

CREATE INDEX entity_name_idx ON entities USING btree ("entity_name");
CREATE INDEX entity_type_idx ON entities USING btree ("entity_type");
CREATE INDEX entity_parent_idx ON entities USING btree ("entity_parent");
CREATE INDEX entity_embed_idx ON entities
USING diskann (entity_embed vector_cosine_ops);

CREATE INDEX entity_gem_embedding_idx ON entities
USING hnsw (gem_embed halfvec_cosine_ops);

CREATE INDEX entity_qwen_embedding_idx ON entities
USING hnsw (qwen_embed halfvec_cosine_ops);


CREATE INDEX entity_keyword_idx ON entities USING GIN (to_tsvector('english', entity_detail));

-- Rename to association?
CREATE TABLE entity_link(
    from_id INTEGER,
    to_id INTEGER,
    entity_strength FLOAT,
    entity_support JSON,
    bidirectional BOOLEAN,
    PRIMARY KEY (from_id, to_id),
    FOREIGN KEY (from_id) REFERENCES entities(entity_id) ON DELETE CASCADE,
    FOREIGN KEY (to_id) REFERENCES entities(entity_id) ON DELETE CASCADE
);

ALTER TABLE entity_link
    ADD COLUMN link_type TEXT;

CREATE TABLE entity_tags(
    entity_id INTEGER,
    tag_name text,
    tag_value text,
    tag_json JSON,
    tag_embed vector(1536),
    PRIMARY KEY (entity_id, tag_name),
    FOREIGN KEY (entity_id) REFERENCES entities(entity_id) ON DELETE CASCADE
);

ALTER TABLE entity_tags
    ADD COLUMN entity_tag_instance INTEGER DEFAULT 1;

ALTER TABLE entity_tags
    DROP CONSTRAINT entity_tags_pkey,
    ADD PRIMARY KEY (entity_id, entity_tag_instance, tag_name);

ALTER TABLE entity_tags
    ADD COLUMN IF NOT EXISTS gem_embed halfvec(3072),
    ADD COLUMN IF NOT EXISTS qwen_embed halfvec(3072);


CREATE INDEX entity_tag_idx ON entity_tags(tag_name);
CREATE INDEX entity_tag_val_idx ON entity_tags(tag_value);
CREATE INDEX entity_tag_embedding_idx ON entity_tags
USING diskann (tag_embed vector_cosine_ops);

CREATE INDEX entity_tag_gem_embedding_idx ON entity_tags
USING hnsw (gem_embed halfvec_cosine_ops);

CREATE INDEX entity_tag_qwen_embedding_idx ON entity_tags
USING hnsw (qwen_embed halfvec_cosine_ops);

CREATE INDEX entity_tag_keyword_idx ON entity_tags USING GIN (to_tsvector('english', tag_value));

CREATE TABLE assessment_criteria (
    criteria_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    criteria_name TEXT,
    criteria_prompt TEXT,
    criteria_promise FLOAT,
    criteria_json JSON,
    criteria_embed vector(1536)
);
ALTER TABLE assessment_criteria 
  ADD COLUMN criteria_scope TEXT;
ALTER TABLE assessment_criteria
    ADD CONSTRAINT unique_assessment_criteria UNIQUE(criteria_name);

ALTER TABLE assessment_criteria
    ADD COLUMN IF NOT EXISTS is_aggregate BOOLEAN default false;

CREATE TABLE association_criteria (
    association_criteria_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    entity1_id INTEGER,
    entity2_id INTEGER,
    entity1_scope TEXT,
    entity2_scope TEXT,
    association_criteria_name TEXT,
    association_criteria_prompt TEXT,
    association_strength FLOAT,
    association_support JSON,
    PRIMARY KEY (association_criteria_id, entity1_id, entity2_id),
    FOREIGN KEY (entity1_id) REFERENCES entities(entity_id) ON DELETE CASCADE,
    FOREIGN KEY (entity2_id) REFERENCES entities(entity_id) ON DELETE CASCADE
);

alter table association_criteria
    add column association_promise float;

ALTER TABLE association_criteria
    ADD COLUMN IF NOT EXISTS is_aggregate BOOLEAN default false;

ALTER TABLE association_criteria
    ADD CONSTRAINT unique_association_criteria UNIQUE(entity1_id, entity2_id, association_criteria_name);
CREATE INDEX assessment_criteria_name_idx ON assessment_criteria USING btree ("criteria_name");
CREATE INDEX assessment_criteria_embed_idx ON assessment_criteria
USING diskann (criteria_embed vector_cosine_ops);

-- The task queue is a list of enrichment tasks to be performed.
CREATE TABLE task_queue(
    task_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    task_name TEXT,
    task_prompt TEXT,
    task_scope TEXT,
    task_description TEXT,
    task_subtasks INTEGER[],
    task_json JSON,
    task_embed vector(1536)
);

ALTER TABLE task_queue
    ADD CONSTRAINT unique_task_name_scope UNIQUE(task_name, task_prompt, task_scope);

CREATE INDEX task_name_idx ON task_queue USING btree ("task_name");
CREATE INDEX task_embed_idx ON task_queue
USING diskann (task_embed vector_cosine_ops);

-- When we index a document as an entity, we want to also capture info about
-- the source document, etc.
CREATE TABLE indexed_documents(
    document_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    document_name TEXT,
    document_url TEXT,
    document_type TEXT,
    document_embed vector(1536),
    document_json JSON
);
ALTER TABLE indexed_documents
    ADD COLUMN entity_id INTEGER REFERENCES entities(entity_id) ON DELETE CASCADE,
    ADD CONSTRAINT unique_documents UNIQUE(document_name, document_url, document_type);

ALTER TABLE indexed_documents
    ADD COLUMN IF NOT EXISTS document_content TEXT;

CREATE INDEX document_name_idx ON indexed_documents USING btree ("document_name");
CREATE INDEX document_url_idx ON indexed_documents USING btree ("document_url");
CREATE INDEX document_type_idx ON indexed_documents USING btree ("document_type");

CREATE INDEX document_embed_idx ON indexed_documents
USING diskann (document_embed vector_cosine_ops);

-- When we index a table as an entity, we want to also link to a stored table
-- in the indexed_tables schema.
CREATE TABLE indexed_tables(
    table_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name TEXT,
    table_url TEXT,
    table_type TEXT,
    table_embed vector(1536),
    table_json JSON
);
ALTER TABLE indexed_tables
    ADD COLUMN entity_id INTEGER REFERENCES entities(entity_id) ON DELETE CASCADE;
CREATE INDEX table_name_idx ON indexed_tables USING btree ("table_name");
CREATE INDEX table_url_idx ON indexed_tables USING btree ("table_url");
CREATE INDEX table_type_idx ON indexed_tables USING btree ("table_type");
CREATE INDEX table_embed_idx ON indexed_tables
USING diskann (table_embed vector_cosine_ops);
CREATE TABLE indexed_figures(
    figure_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    figure_name TEXT,
    figure_url TEXT,
    figure_type TEXT,
    figure_embed vector(1536),
    figure_json JSON
);
ALTER TABLE indexed_figures
    ADD COLUMN entity_id INTEGER REFERENCES entities(entity_id) ON DELETE CASCADE;
CREATE INDEX figure_name_idx ON indexed_figures USING btree ("figure_name");
CREATE INDEX figure_url_idx ON indexed_figures USING btree ("figure_url");
CREATE INDEX figure_type_idx ON indexed_figures USING btree ("figure_type");
CREATE INDEX figure_embed_idx ON indexed_figures
USING diskann (figure_embed vector_cosine_ops);

CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE user_profiles (
    profile_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(user_id) ON DELETE CASCADE,
    profile_data JSON,
    profile_context TEXT,
    scholar_id VARCHAR,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE projects (
    project_id SERIAL PRIMARY KEY,
    project_name TEXT NOT NULL,
    project_description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    parent_project_id INTEGER REFERENCES projects(project_id) ON DELETE SET NULL
);

CREATE TABLE user_projects (
    user_id INTEGER REFERENCES users(user_id) ON DELETE CASCADE,
    project_id INTEGER REFERENCES projects(project_id) ON DELETE CASCADE,
    role TEXT,
    context TEXT,
    PRIMARY KEY (user_id, project_id)
);

CREATE TABLE project_tasks (
    task_id SERIAL PRIMARY KEY,
    project_id INTEGER REFERENCES projects(project_id) ON DELETE CASCADE,
    task_name TEXT NOT NULL,
    task_description TEXT,
    task_context TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add columns for biosketch, research areas, projects to user_profiles if not present
ALTER TABLE user_profiles
    ADD COLUMN IF NOT EXISTS biosketch TEXT,
    ADD COLUMN IF NOT EXISTS research_areas TEXT,
    ADD COLUMN IF NOT EXISTS projects TEXT,
    ADD COLUMN IF NOT EXISTS publications JSON;

ALTER TABLE project_tasks 
  ADD COLUMN task_schema text;
COMMENT ON COLUMN project_tasks.task_schema IS 'For capturing a string list of attributes:types;descriptions';

ALTER TABLE project_tasks 
  ADD COLUMN task_description_embed vector(1536);

CREATE INDEX task_description_embed_idx ON project_tasks
USING hnsw (task_description_embed vector_cosine_ops);

CREATE TABLE task_entities (
    task_entity_id SERIAL PRIMARY KEY,
    task_id INTEGER REFERENCES project_tasks(task_id) ON DELETE CASCADE,
    entity_id INTEGER REFERENCES entities(entity_id) ON DELETE CASCADE,
    user_feedback TEXT,
    feedback_rating INTEGER,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (task_id, entity_id)
);

CREATE TYPE data_flow_type AS ENUM ('automatic', 'gated by user feedback', 'rethinking the previous task');

ALTER TYPE data_flow_type ADD VALUE IF NOT EXISTS 'parent task-subtask';


CREATE TABLE task_dependencies (
    source_task_id INTEGER REFERENCES project_tasks(task_id) ON DELETE CASCADE,
    dependent_task_id INTEGER REFERENCES project_tasks(task_id) ON DELETE CASCADE,
    relationship_description TEXT,
    data_schema TEXT,
    data_flow data_flow_type,
    PRIMARY KEY (source_task_id, dependent_task_id)
);

CREATE TABLE crawl_cache (
    cache_id SERIAL PRIMARY KEY,
    url TEXT NOT NULL UNIQUE,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    digest TEXT NOT NULL UNIQUE
);

ALTER TABLE crawl_cache
    ADD COLUMN IF NOT EXISTS extracted_json JSON;

ALTER TABLE users
    ADD COLUMN IF NOT EXISTS name TEXT;

ALTER TABLE users
    ADD COLUMN IF NOT EXISTS organization TEXT;

ALTER TABLE users
    ADD COLUMN IF NOT EXISTS avatar TEXT;

---------- Some useful views ----------------

CREATE VIEW paragraph_tags_view AS
    SELECT entity_id AS paragraph_id, tag_name, tag_value
    FROM entity_tags
    UNION
    select entities.entity_id as paragraph_id, tag_name, tag_value
    from entities JOIN entity_tags ON entity_tags.entity_id = entities.entity_parent
    WHERE entities.entity_type = 'paragraph';


CREATE VIEW authors_view AS
    SELECT entity_id, entity_name, entity_contact, entity_detail
    FROM entities
    WHERE entity_type = 'author';

CREATE VIEW papers_view AS
    SELECT entity_id, entity_name, entity_url
    FROM entities
    WHERE entity_type = 'paper';

CREATE VIEW paragraphs_view AS
    SELECT entity_id, entity_name, entity_parent
    FROM entities
    WHERE entity_type = 'paragraph';

DROP VIEW IF EXISTS paragraphs_papers_authors_view;
CREATE VIEW paragraphs_papers_authors_view AS
    SELECT para.entity_detail, paper.entity_url, author.tag_value as author
    FROM entities para JOIN entities paper ON para.entity_parent = paper.entity_id
    JOIN entity_tags author ON paper.entity_id = author.entity_id
    WHERE para.entity_type = 'paragraph' and paper.entity_type = 'paper' and author.tag_name = 'author';

grant select, insert, update, delete on all tables in schema public to kair;

create schema indexed_tables;

grant create on schema indexed_tables to kair;

GRANT USAGE ON SCHEMA indexed_tables TO kair;

ALTER DEFAULT PRIVILEGES IN SCHEMA indexed_tables GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO kair;

ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO kair;

grant select, insert, update, delete on all tables in schema indexed_tables to kair;

GRANT USAGE ON SEQUENCE users_user_id_seq TO kair;

GRANT USAGE ON SEQUENCE crawl_queue_id_seq TO kair;
GRANT USAGE ON SEQUENCE strategies_strategy_id_seq TO kair;
GRANT USAGE ON SEQUENCE entities_entity_id_seq TO kair;
GRANT USAGE ON SEQUENCE assessment_criteria_criteria_id_seq TO kair;
GRANT USAGE ON SEQUENCE association_criteria_association_criteria_id_seq TO kair;
GRANT USAGE ON SEQUENCE task_queue_task_id_seq TO kair;
GRANT USAGE ON SEQUENCE indexed_documents_document_id_seq TO kair;
GRANT USAGE ON SEQUENCE indexed_tables_table_id_seq TO kair;
GRANT USAGE ON SEQUENCE indexed_figures_figure_id_seq TO kair;
GRANT USAGE ON SEQUENCE crawl_cache_cache_id_seq TO kair;
GRANT USAGE ON SEQUENCE indexed_tables_table_id_seq TO kair;

GRANT USAGE ON SEQUENCE user_profiles_profile_id_seq TO kair;

GRANT USAGE ON SEQUENCE projects_project_id_seq TO kair;

GRANT USAGE ON SEQUENCE project_tasks_task_id_seq TO kair;

GRANT USAGE ON SEQUENCE user_history_history_id_seq TO kair;

GRANT USAGE ON SEQUENCE user_history_history_id_seq TO kair;

GRANT USAGE ON SEQUENCE task_entities_task_entity_id_seq TO kair;

create view papers_summaries_fields_authors_view AS
  SELECT e.entity_id, e.entity_name, e.entity_detail, f.tag_value as "field", s.tag_value as summary, a.tag_value as author
  FROM entities e join entity_tags a on e.entity_id = a.entity_id JOIN entity_tags s on e.entity_id = s.entity_id JOIN entity_tags f on e.entity_id = f.entity_id
  WHERE a.tag_name = 'author' and s.tag_name = 'summary' and f.tag_name = 'field' and e.entity_type = 'paper';

CREATE TABLE IF NOT EXISTS user_history (
    history_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(user_id) ON DELETE CASCADE,
    project_id INTEGER REFERENCES projects(project_id) ON DELETE CASCADE,
    task_id INTEGER REFERENCES project_tasks(task_id) ON DELETE CASCADE,
    prompt TEXT,
    response TEXT,
    predicted_task_description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

ALTER SEQUENCE crawl_cache_cache_id_seq RESTART WITH 960;
