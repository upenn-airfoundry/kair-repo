
CREATE USER kair with password 'kair_pass';

create role kair with login password 'kair_pass';
-- grant kair to kair;

grant connect on database postgres to kair;
grant usage on schema public to kair;

CREATE EXTENSION IF NOT EXISTS vectorscale CASCADE;

-- Generated by the database client.
CREATE TABLE crawl_queue(
    id integer GENERATED ALWAYS AS IDENTITY NOT NULL,
    create_time date,
    url varchar(4096),
    comment varchar(255),
    PRIMARY KEY(id)
);
-- Generated by the database client.
CREATE TABLE crawled(
    id integer NOT NULL,
    crawl_time date NOT NULL,
    path varchar(255),
    PRIMARY KEY(id,crawl_time),
    CONSTRAINT crawled_id_fkey FOREIGN key(id) REFERENCES crawl_queue(id)
);

--   CREATE TABLE papers(
--     id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     title TEXT,
--     abstract TEXT,
--     url TEXT,
--     crawl_time DATE
-- )

-- ALTER TABLE papers
--     ADD CONSTRAINT unique_papers UNIQUE(url, crawl_time);

-- CREATE TABLE paragraphs(  
--     paragraph_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
--     paper_id int,
--     paragraph_text TEXT,
--     embedding vector(1536),
--     PRIMARY KEY (paragraph_id),
--     FOREIGN KEY (paper_id) REFERENCES papers(id) ON DELETE CASCADE
-- );

-- CREATE INDEX para_embedding_idx ON paragraphs
-- USING diskann (embedding vector_cosine_ops);
-- --COMMENT ON TABLE crawl_queue IS '';
-- --COMMENT ON COLUMN table_name.name IS '';

-- CREATE TABLE paragraph_tags(
--     paragraph_id INTEGER,
--     tag TEXT,
--     PRIMARY KEY (paragraph_id, tag),
--     FOREIGN KEY (paragraph_id) REFERENCES paragraphs(paragraph_id) ON DELETE CASCADE
-- );
CREATE TABLE strategies(
    strategy_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    strategy_name TEXT,
    strategy_prompt TEXT,
    strategy_promise FLOAT,
    strategy_json JSON,
    strategy_embed vector(1536)
);

ALTER TABLE strategies 
  ADD COLUMN strategy_scope TEXT,
  ADD COLUMN sub_strategies INTEGER[],
  ADD COLUMN description TEXT;

CREATE INDEX strategy_name_idx ON strategies USING btree ("strategy_name");
CREATE INDEX strategy_embed_idx ON strategies
USING diskann (strategy_embed vector_cosine_ops);
CREATE INDEX strategy_sub_strategies_idx ON strategies USING btree ("sub_strategies");

CREATE TYPE entity_types AS ENUM ('synopsis', 
                                  'fact', 
                                  'new_concept',
                                  'claim',
                                  'author', 
                                  'organization', 
                                  'tag', 
                                  'paper', 
                                  'section', 
                                  'paragraph',
                                  'table',
                                  'hypothesis',
                                  'source',
                                  'method',
                                  'event',
                                  'result');

CREATE TABLE entities(
    entity_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_type entity_types,
    entity_name TEXT,
    entity_parent INTEGER,
    entity_embed vector(1536),
    FOREIGN KEY (entity_parent) REFERENCES entities(entity_id) ON DELETE CASCADE
);
ALTER TABLE entities
    ADD CONSTRAINT unique_entities UNIQUE(entity_type, entity_name),
    ADD CONSTRAINT unique_entity_parent UNIQUE(entity_type, entity_name, entity_parent);
ALTER TABLE entities
    ADD COLUMN IF NOT EXISTS entity_detail TEXT,
    ADD COLUMN IF NOT EXISTS entity_url TEXT,
    ADD COLUMN IF NOT EXISTS entity_contact TEXT,
    ADD COLUMN IF NOT EXISTS entity_json JSON;
ALTER TABLE entities
    ADD COLUMN IF NOT EXISTS supporting_evidence INTEGER,
    ADD FOREIGN KEY (supporting_evidence) REFERENCES entities(entity_id) ON DELETE CASCADE;
ALTER TABLE entities
    ADD FOREIGN KEY (supporting_evidence) REFERENCES entities(entity_id) ON DELETE CASCADE;


CREATE INDEX entity_name_idx ON entities USING btree ("entity_name");
CREATE INDEX entity_type_idx ON entities USING btree ("entity_type");
CREATE INDEX entity_parent_idx ON entities USING btree ("entity_parent");
CREATE INDEX entity_embed_idx ON entities
USING diskann (entity_embed vector_cosine_ops);

CREATE INDEX entity_keyword_idx ON entities USING GIN (to_tsvector('english', entity_detail));

-- Rename to assocation?
CREATE TABLE entity_link(
    from_id INTEGER,
    to_id INTEGER,
    entity_strength FLOAT,
    entity_support JSON,
    bidirectional BOOLEAN,
    PRIMARY KEY (from_id, to_id),
    FOREIGN KEY (from_id) REFERENCES entities(entity_id) ON DELETE CASCADE,
    FOREIGN KEY (to_id) REFERENCES entities(entity_id) ON DELETE CASCADE
);

ALTER TABLE entity_link
    ADD COLUMN link_type TEXT;

CREATE TABLE entity_tags(
    entity_id INTEGER,
    tag_name text,
    tag_value text,
    tag_json JSON,
    tag_embed vector(1536),
    PRIMARY KEY (entity_id, tag_name),
    FOREIGN KEY (entity_id) REFERENCES entities(entity_id) ON DELETE CASCADE
);

CREATE INDEX entity_tag_idx ON entity_tags(tag_name);
CREATE INDEX entity_tag_val_idx ON entity_tags(tag_value);
CREATE INDEX entity_tag_embedding_idx ON entity_tags
USING diskann (tag_embed vector_cosine_ops);


CREATE INDEX entity_tag_keyword_idx ON entity_tags USING GIN (to_tsvector('english', tag_value));

CREATE TABLE assessment_criteria (
    criteria_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    criteria_name TEXT,
    criteria_prompt TEXT,
    criteria_promise FLOAT,
    criteria_json JSON,
    criteria_embed vector(1536)
);
ALTER TABLE assessment_criteria 
  ADD COLUMN criteria_scope TEXT;
ALTER TABLE assessment_criteria
    ADD CONSTRAINT unique_assessment_criteria UNIQUE(criteria_name);


CREATE TABLE association_criteria (
    association_criteria_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    entity1_id INTEGER,
    entity2_id INTEGER,
    entity1_scope TEXT,
    entity2_scope TEXT,
    association_criteria_name TEXT,
    association_criteria_prompt TEXT,
    association_strength FLOAT,
    association_support JSON,
    PRIMARY KEY (association_criteria_id, entity1_id, entity2_id),
    FOREIGN KEY (entity1_id) REFERENCES entities(entity_id) ON DELETE CASCADE,
    FOREIGN KEY (entity2_id) REFERENCES entities(entity_id) ON DELETE CASCADE
);

ALTER TABLE association_criteria
    ADD CONSTRAINT unique_association_criteria UNIQUE(entity1_id, entity2_id, association_criteria_name);
CREATE INDEX assessment_criteria_name_idx ON assessment_criteria USING btree ("criteria_name");
CREATE INDEX assessment_criteria_embed_idx ON assessment_criteria
USING diskann (criteria_embed vector_cosine_ops);

CREATE TABLE task_queue(
    task_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    task_name TEXT,
    task_prompt TEXT,
    task_scope TEXT,
    task_description TEXT,
    task_subtasks INTEGER[],
    task_json JSON,
    task_embed vector(1536)
);

CREATE INDEX task_name_idx ON task_queue USING btree ("task_name");
CREATE INDEX task_embed_idx ON task_queue
USING diskann (task_embed vector_cosine_ops);

CREATE TABLE indexed_documents(
    document_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    document_name TEXT,
    document_url TEXT,
    document_type TEXT,
    document_embed vector(1536),
    document_json JSON
);
ALTER TABLE indexed_documents
    ADD COLUMN entity_id INTEGER REFERENCES entities(entity_id) ON DELETE CASCADE,
    ADD CONSTRAINT unique_documents UNIQUE(document_name, document_url, document_type);

CREATE INDEX document_name_idx ON indexed_documents USING btree ("document_name");
CREATE INDEX document_url_idx ON indexed_documents USING btree ("document_url");
CREATE INDEX document_type_idx ON indexed_documents USING btree ("document_type");

CREATE INDEX document_embed_idx ON indexed_documents
USING diskann (document_embed vector_cosine_ops);

CREATE TABLE indexed_tables(
    table_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name TEXT,
    table_url TEXT,
    table_type TEXT,
    table_embed vector(1536),
    table_json JSON
);
ALTER TABLE indexed_tables
    ADD COLUMN entity_id INTEGER REFERENCES entities(entity_id) ON DELETE CASCADE;
CREATE INDEX table_name_idx ON indexed_tables USING btree ("table_name");
CREATE INDEX table_url_idx ON indexed_tables USING btree ("table_url");
CREATE INDEX table_type_idx ON indexed_tables USING btree ("table_type");
CREATE INDEX table_embed_idx ON indexed_tables
USING diskann (table_embed vector_cosine_ops);
CREATE TABLE indexed_figures(
    figure_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    figure_name TEXT,
    figure_url TEXT,
    figure_type TEXT,
    figure_embed vector(1536),
    figure_json JSON
);
ALTER TABLE indexed_figures
    ADD COLUMN entity_id INTEGER REFERENCES entities(entity_id) ON DELETE CASCADE;
CREATE INDEX figure_name_idx ON indexed_figures USING btree ("figure_name");
CREATE INDEX figure_url_idx ON indexed_figures USING btree ("figure_url");
CREATE INDEX figure_type_idx ON indexed_figures USING btree ("figure_type");
CREATE INDEX figure_embed_idx ON indexed_figures
USING diskann (figure_embed vector_cosine_ops);

CREATE VIEW paragraph_tags_view AS
    SELECT entity_id AS paragraph_id, tag_name, tag_value
    FROM entity_tags
    UNION
    select entities.entity_id as paragraph_id, tag_name, tag_value
    from entities JOIN entity_tags ON entity_tags.entity_id = entities.entity_parent
    WHERE entities.entity_type = 'paragraph';


CREATE VIEW authors_view AS
    SELECT entity_id, entity_name, entity_contact, entity_detail
    FROM entities
    WHERE entity_type = 'author';

CREATE VIEW papers_view AS
    SELECT entity_id, entity_name, entity_url
    FROM entities
    WHERE entity_type = 'paper';

CREATE VIEW paragraphs_view AS
    SELECT entity_id, entity_name, entity_parent
    FROM entities
    WHERE entity_type = 'paragraph';

CREATE VIEW paragraphs_papers_authors_view AS
    SELECT para.entity_detail, paper.entity_url, author.entity_name, author.entity_contact
    FROM entities para JOIN entities paper ON para.entity_parent = paper.entity_id
    JOIN entities author ON paper.entity_parent = author.entity_id
    WHERE para.entity_type = 'paragraph' and paper.entity_type = 'paper' and author.entity_type = 'author';

grant select, insert, update, delete on all tables in schema public to kair;

create schema indexed_tables;

grant select, insert, update, delete on all tables in schema public to kair;

grant create on schema indexed_tables to kair;

GRANT USAGE ON SCHEMA indexed_tables TO kair;

ALTER DEFAULT PRIVILEGES IN SCHEMA indexed_tables GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO kair;

ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO kair;

grant select, insert, update, delete on all tables in schema indexed_tables to kair;
